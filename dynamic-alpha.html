<!doctypehtml><html lang=en><meta content="Julien Barbay"name=author><meta content="Julien Barbay"property=og:title><meta content=@y_nk name=twitter:creator><meta content=summary name=twitter:card><meta charset=utf-8><meta content="IE=edge"http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1"name=viewport><title>y_nk – Dynamic alpha</title><link href=./style.css rel=stylesheet><link href=./favicon.svg rel=icon type=image/svg+xml><link href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/styles/paraiso-dark.min.css rel=stylesheet><script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><meta content="Observations on obstruction of background and what we can do about it"name=description><meta content="Observations on obstruction of background and what we can do about it"name=og:description><meta content=././dynamic-alpha.html name=og:url><body class=post><header><h1><a href=./ ><svg id=y_nk viewBox="0 0 100 65"><polygon class=bk points="10.1,0 20.3,10.1 0,10.1"></polygon><polygon class=ft points="20.3,10.1 46.2,36.1 36.1,46.2 0,10.1"></polygon><polygon class=bk points="35.6,10.1 45.8,20.3 45.8,0"></polygon><polygon class=ft points="89.9,44.3 89.9,64.6 45.8,20.3 45.8,0"></polygon><polygon class=bk points="89.9,0 79.7,10.1 100,10.1"></polygon><polygon class=ft points="79.7,10.1 75.3,14.6 85.4,24.7 100,10.1"></polygon><polygon class=bk points="100,54.4 89.9,44.3 89.9,64.6"></polygon></svg></a></h1></header><section id=main><hgroup><h2>Dynamic alpha</h2><h6>July 25th, 2011</h6></hgroup><article><p><disclaimer>The original article has been retrieved from the internet archive machine and edited for fluidity.</disclaimer><p>Since early 2010, coverflows have appeared everywhere on the internet. They're considered one of the best way to show lots of things in a small space, thanks to their hidden "slides".<p>Most of the time, you can expect a simple box with an image, and a overlay with a semi-transparent black background and white font color. Just by saying it, you can smell the shit happening and despite your tries to educate your client about it, most of the time what you predicted becomes reality.<p>With a bright image, if the black background is too opaque, you hiding some parts of the image but you also change the perception you had about shape of the image. If the black background is too transparent, you may find the white font unreadable very quickly.<p>So I went up with this stupid and almost useless idea to adapt the alpha of the background depending on what’s behind. That way, wherever the overlay could be, the alpha would always be the way it should to provide a good compromize between the visibility of the image and the readability of the font.<p>For a small proof of concept, i just put 4 greys and tried differents overlay. To see what i meant with visibility and readability, i made those overlays draggable:</p><style>#container-1{display:flex}#experiment-1{position:relative;margin:2em auto 2.5em}#experiment-1 canvas{display:block}#experiment-1 div{position:absolute;padding:2px 4px;background:rgba(0,0,0,.5);color:#fff;user-select:none}</style><div id=container-1><div id=experiment-1><canvas></canvas><div rel=futsu style=left:30px;top:60px;background:rgba(0,0,0,.2)>Non Adaptive (.2)</div><div rel=futsu style=left:175px;top:100px;background:rgba(0,0,0,.8)>Non Adaptive (.8)</div><div rel=smart style=left:140px;top:225px;background:rgba(0,0,0,0)>Adaptive</div></div></div><script>(()=>{const e=document.querySelector("#experiment-1"),t=e.querySelector('div[rel="smart"]'),l=e.querySelector("canvas"),n=l.getContext("2d");l.height=l.width;const r=.5*l.width,s=.5*l.height;n.fillStyle="#333",n.fillRect(0,0,r,s),n.fillStyle="#666",n.fillRect(r,0,r,s),n.fillStyle="#999",n.fillRect(0,s,r,s),n.fillStyle="#ccc",n.fillRect(r,s,r,s);const i=()=>{const e=parseInt(t.style.left),l=parseInt(t.style.top),r=t.clientWidth,s=t.clientHeight,{data:i}=n.getImageData(e,l,r,s);let o=0;for(let e=0;e<i.length;e+=4)o+=i[e];o/=i.length/4;const c=.2+o/255*.6;t.style.background=`rgba(0, 0, 0, ${c})`};i();let o=!1;e.addEventListener("mouseenter",e=>o=!0),e.addEventListener("mouseleave",e=>o=!1),document.addEventListener("mousemove",e=>{if(!o||0===e.buttons)return;if(!e.target.getAttribute("rel"))return;const l=e.target,n=parseInt(l.style.left)+e.movementX,r=parseInt(l.style.top)+e.movementY;l.style.left=(n>=0?n:0)+"px",l.style.top=(r>=0?r:0)+"px",l===t&&i()})})()</script><p>I turned to be usefull with a real image.<p>Here, i put the .8 alpha overlay on dark side but onto bright details, which are lost behind the overly black background ; the .2 alpha overlay on a bright area to show that a too transparent background could affect the readability of a text. The perfect case would be to switch them but… we can't always predict which image will be loaded in a carousel. Hopefully, the dynamic overlay fits everywhere correctly !</p><style>#container-2{display:flex}#experiment-2{position:relative;margin:2em 0 2.5em}#experiment-2 canvas{display:block;width:100%}#experiment-2 div{position:absolute;padding:2px 4px;background:rgba(0,0,0,.5);color:#fff;user-select:none}</style><div id=container-2><div id=experiment-2><canvas></canvas><div rel=futsu style=left:570px;top:70px;background:rgba(0,0,0,.2)>Non Adaptive (.2)</div><div rel=futsu style=left:175px;top:100px;background:rgba(0,0,0,.8)>Non Adaptive (.8)</div><div rel=smart style=left:140px;top:225px;background:rgba(0,0,0,0)>Adaptive</div></div></div><script>(()=>{const e=document.querySelector("#experiment-2"),t=e.querySelector('div[rel="smart"]'),n=e.querySelector("canvas"),a=n.getContext("2d"),r=new Image;r.src="./images/dynamic-alpha.jpg",r.onload=()=>{n.width=r.naturalWidth,n.height=r.naturalHeight,a.drawImage(r,0,0)};const l=()=>{const e=n.clientWidth/n.width,r=parseInt(t.style.left)*e,l=parseInt(t.style.top)*e,s=t.clientWidth,o=t.clientHeight,{data:i}=a.getImageData(r,l,s,o);let d=0;for(let e=0;e<i.length;e+=4)d+=i[e];d/=i.length/4;const c=.2+d/255*.6;t.style.background=`rgba(0, 0, 0, ${c})`};l();let s=!1;e.addEventListener("mouseenter",e=>s=!0),e.addEventListener("mouseleave",e=>s=!1),document.addEventListener("mousemove",e=>{if(!s||0===e.buttons)return;if(!e.target.getAttribute("rel"))return;const n=e.target,a=parseInt(n.style.left)+e.movementX,r=parseInt(n.style.top)+e.movementY;n.style.left=(a>=0?a:0)+"px",n.style.top=(r>=0?r:0)+"px",n===t&&l()})})()</script><pre><code>var rect:Rectangle = new Rectangle(overlay.x, overlay.y, overlay.width, overlay.height);
var ba:ByteArray = image.bitmapData.getPixels(rect);

ba.position = 0;
var total:uint, color:Array;
while (ba.position &lt; ba.length)
{
    color = int2rgb(ba.readUnsignedInt() - 0xff000000);
    total += color[0] &lt; color[1] ? color[1] &lt; color[2] ? color[2] : color[1] : color[0];
}

var average:Number = (total / luminosity.position) / 100;
var ratio:Number = total / (0xff * luminosity.position);

overlay.refresh({ text:'dynamic alpha (' + average.toFixed(2) + ')', alpha:average })</code></pre><p><disclaimer>The original code was for AS3, so here's a HTML5 canvas version</disclaimer><pre><code>const getOpacityForRegion = (context, x, y, w, h, min = 0, max = 1) => {
    const { data } = context.getImageData(x, y, w, h)

    let average = 0
    for (let i = 0; i &lt; data.length; i += 4)
        average += data[i]

    average /= (data.length / 4)
    return min + (average / 255) * (max - min)
}</code></pre></article></section><footer><a href=./ class=!>← back</a></footer><script>const colors=["blue","cornflowerblue","darkorange","darkturquoise","deepskyblue","dodgerblue","gold","goldenrod","indigo","lightcoral","lightgreen","lightpink","lightseagreen","lightskyblue","lightslategray","limegreen","mediumaquamarine","mediumblue","mediumspringgreen","midnightblue","moccasin","navajowhite","orange","orangered","palegreen","paleturquoise","pink","rebeccapurple","royalblue","salmon","sandybrown","seagreen","skyblue","springgreen","steelblue","teal","tomato"];document.body.style.setProperty("--accent",colors[Math.floor(Math.random()*colors.length)])</script>