<!DOCTYPE html><html lang="en"><head>
    <meta name="author" content="Julien Barbay">
    <meta name="twitter:creator" content="@y_nk">
    <meta name="twitter:card" content="summary">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>y_nk – Dynamic alpha</title>

    <link rel="stylesheet" type="text/css" href="./style.css">
    <link rel="icon" type="image/svg+xml" href="./favicon.svg">
    <link rel="alternate" type="application/rss+xml" href="./feed.xml">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/styles/paraiso-dark.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  <meta property="og:type" content="article"><meta property="article:author" content="Julien Barbay"><meta property="og:title" content="Dynamic alpha"><meta property="description" content="Observations on obstruction of background and what we can do about it"><meta property="og:description" content="Observations on obstruction of background and what we can do about it"><meta property="og:url" content="/dynamic-alpha.html"><meta property="article:published_time" content="1311519600000"></head>

  <body class="post">
    <header>
      <h1><a href="./">
        <svg id="y_nk" viewBox="0 0 100 65">
          <polygon class="bk" points="10.1,0 20.3,10.1 0,10.1"></polygon>
          <polygon class="ft" points="20.3,10.1 46.2,36.1 36.1,46.2 0,10.1"></polygon>
          <polygon class="bk" points="35.6,10.1 45.8,20.3 45.8,0"></polygon>
          <polygon class="ft" points="89.9,44.3 89.9,64.6 45.8,20.3 45.8,0"></polygon>
          <polygon class="bk" points="89.9,0 79.7,10.1 100,10.1"></polygon>
          <polygon class="ft" points="79.7,10.1 75.3,14.6 85.4,24.7 100,10.1"></polygon>
          <polygon class="bk" points="100,54.4 89.9,44.3 89.9,64.6"></polygon>
        </svg>
      </a></h1>
    </header>

    <section id="main">
  <hgroup>
    <h2>Dynamic alpha</h2>
    <h6>July 24th, 2011</h6>
  </hgroup>
 <article>
    <p><disclaimer>The original article has been retrieved from the internet archive machine and edited for fluidity.</disclaimer></p>
<p>Since early 2010, coverflows have appeared everywhere on the internet. They're considered one of the best way to show lots of things in a small space, thanks to their hidden "slides".</p>
<p>Most of the time, you can expect a simple box with an image, and a overlay with a semi-transparent black background and white font color. Just by saying it, you can smell the shit happening and despite your tries to educate your client about it, most of the time what you predicted becomes reality.</p>
<p>With a bright image, if the black background is too opaque, you hiding some parts of the image but you also change the perception you had about shape of the image. If the black background is too transparent, you may find the white font unreadable very quickly.</p>
<p>So I went up with this stupid and almost useless idea to adapt the alpha of the background depending on what’s behind. That way, wherever the overlay could be, the alpha would always be the way it should to provide a good compromize between the visibility of the image and the readability of the font.</p>
<p>For a small proof of concept, i just put 4 greys and tried differents overlay. To see what i meant with visibility and readability, i made those overlays draggable:</p>
<style>
#container-1 {
    display: flex;
}

#experiment-1 {
    position: relative;
    margin: 2em auto 2.5em;
}

#experiment-1 canvas {
    display: block;
}

#experiment-1 div {
    position: absolute;
    padding: 2px 4px;
    background: rgba(0, 0, 0, .5);
    color: #fff;
    user-select: none;
}
</style>

<div id="container-1">
    <div id="experiment-1">
        <canvas></canvas>
        <div rel="futsu" style="left: 30px; top: 60px; background: rgba(0, 0, 0, .2)">Non Adaptive (.2)</div>
        <div rel="futsu" style="left: 175px; top: 100px; background: rgba(0, 0, 0, .8)">Non Adaptive (.8)</div>
        <div rel="smart" style="left: 140px; top: 225px; background: rgba(0, 0, 0, 0)">Adaptive</div>
    </div>
</div>

<script type="text/javascript">
    ;(() => {
        const container = document.querySelector('#experiment-1')
        const overlay = container.querySelector('div[rel="smart"]')
        const canvas = container.querySelector('canvas')
        const context = canvas.getContext('2d')

        canvas.height = canvas.width
        const w = canvas.width  * .5
        const h = canvas.height * .5

        context.fillStyle = '#333'
        context.fillRect(0, 0, w, h)
        context.fillStyle = '#666'
        context.fillRect(w, 0, w, h)
        context.fillStyle = '#999'
        context.fillRect(0, h, w, h)
        context.fillStyle = '#ccc'
        context.fillRect(w, h, w, h)

        const refresh = () => {
            const x = parseInt(overlay.style.left)
            const y = parseInt(overlay.style.top)
            const w = overlay.clientWidth
            const h = overlay.clientHeight

            const { data } = context.getImageData(x, y, w, h)

            let average = 0
            for (let i = 0; i < data.length; i += 4)
                average += data[i]

            average /= (data.length / 4)
            const opacity = .2 + (average / 255) * .6
            overlay.style.background = `rgba(0, 0, 0, ${opacity})`
        }

        refresh()

        let active = false
        container.addEventListener('mouseenter', e => active = true)
        container.addEventListener('mouseleave', e => active = false)

        document.addEventListener('mousemove', e => {
            if (!active || e.buttons === 0)
                return

            if (!e.target.getAttribute('rel'))
                return

            const target = e.target

            const x = parseInt(target.style.left) + e.movementX
            const y = parseInt(target.style.top) + e.movementY
            target.style.left = `${x >= 0 ? x : 0}px`
            target.style.top = `${y >= 0 ? y : 0}px`

            if (target === overlay)
                refresh()
        })
    })()
</script>

<p>I turned to be usefull with a real image.</p>
<p>Here, i put the .8 alpha overlay on dark side but onto bright details, which are lost behind the overly black background ;  the .2 alpha overlay on a bright area to show that a too transparent background could affect the readability of a text. The perfect case would be to switch them but… we can't always predict which image will be loaded in a carousel. Hopefully, the dynamic overlay fits everywhere correctly !</p>
<style>
#container-2 {
    display: flex;
}

#experiment-2 {
    position: relative;
    margin: 2em 0 2.5em;
}

#experiment-2 canvas {
    display: block;
    width: 100%;
}

#experiment-2 div {
    position: absolute;
    padding: 2px 4px;
    background: rgba(0, 0, 0, .5);
    color: #fff;
    user-select: none;
}
</style>

<div id="container-2">
    <div id="experiment-2">
        <canvas></canvas>
        <div rel="futsu" style="left: 570px; top: 70px; background: rgba(0, 0, 0, .2)">Non Adaptive (.2)</div>
        <div rel="futsu" style="left: 175px; top: 100px; background: rgba(0, 0, 0, .8)">Non Adaptive (.8)</div>
        <div rel="smart" style="left: 140px; top: 225px; background: rgba(0, 0, 0, 0)">Adaptive</div>
    </div>
</div>

<script type="text/javascript">
    ;(() => {
        const container = document.querySelector('#experiment-2')
        const overlay = container.querySelector('div[rel="smart"]')
        const canvas = container.querySelector('canvas')
        const context = canvas.getContext('2d')

        const ratio = () => canvas.clientWidth / canvas.width

        const image = new Image()
        image.src = './images/dynamic-alpha.jpg'
        image.onload = () => {
            canvas.width = image.naturalWidth
            canvas.height = image.naturalHeight
            context.drawImage(image, 0, 0)
        }

        const refresh = () => {
            const r = ratio()
            const x = parseInt(overlay.style.left) * r
            const y = parseInt(overlay.style.top) * r
            const w = overlay.clientWidth
            const h = overlay.clientHeight

            const { data } = context.getImageData(x, y, w, h)

            let average = 0
            for (let i = 0; i < data.length; i += 4)
                average += data[i]

            average /= (data.length / 4)
            const opacity = .2 + (average / 255) * .6
            overlay.style.background = `rgba(0, 0, 0, ${opacity})`
        }

        refresh()

        let active = false
        container.addEventListener('mouseenter', e => active = true)
        container.addEventListener('mouseleave', e => active = false)

        document.addEventListener('mousemove', e => {
            if (!active || e.buttons === 0)
                return

            if (!e.target.getAttribute('rel'))
                return

            const target = e.target

            const x = parseInt(target.style.left) + e.movementX
            const y = parseInt(target.style.top) + e.movementY
            target.style.left = `${x >= 0 ? x : 0}px`
            target.style.top = `${y >= 0 ? y : 0}px`

            if (target === overlay)
                refresh()
        })
    })()
</script>

<pre><code>var rect:Rectangle = new Rectangle(overlay.x, overlay.y, overlay.width, overlay.height);
var ba:ByteArray = image.bitmapData.getPixels(rect);

ba.position = 0;
var total:uint, color:Array;
while (ba.position &lt; ba.length)
{
    color = int2rgb(ba.readUnsignedInt() - 0xff000000);
    total += color[0] &lt; color[1] ? color[1] &lt; color[2] ? color[2] : color[1] : color[0];
}

var average:Number = (total / luminosity.position) / 100;
var ratio:Number = total / (0xff * luminosity.position);

overlay.refresh({ text:'dynamic alpha (' + average.toFixed(2) + ')', alpha:average })</code></pre>
<p><disclaimer>The original code was for AS3, so here's a HTML5 canvas version</disclaimer></p>
<pre><code>const getOpacityForRegion = (context, x, y, w, h, min = 0, max = 1) =&gt; {
    const { data } = context.getImageData(x, y, w, h)

    let average = 0
    for (let i = 0; i &lt; data.length; i += 4)
        average += data[i]

    average /= (data.length / 4)
    return min + (average / 255) * (max - min)
}</code></pre>

  </article></section>

    <footer>
      <a href="./" class="!">← back</a>
    </footer>

    <script>
      const colors = ['blue', 'cornflowerblue', 'darkorange', 'darkturquoise', 'deepskyblue', 'dodgerblue',
        'gold', 'goldenrod', 'indigo', 'lightcoral', 'lightgreen', 'lightpink', 'lightseagreen', 'lightskyblue',
        'lightslategray', 'limegreen', 'mediumaquamarine', 'mediumblue', 'mediumspringgreen', 'midnightblue',
        'moccasin', 'navajowhite', 'orange', 'orangered', 'palegreen', 'paleturquoise', 'pink', 'rebeccapurple',
        'royalblue', 'salmon', 'sandybrown', 'seagreen', 'skyblue', 'springgreen', 'steelblue', 'teal', 'tomato']

      document.body.style.setProperty('--accent', colors[Math.floor(Math.random() * colors.length)])
    </script>
  

</body></html>